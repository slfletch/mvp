---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: curl
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: search
spec:
  description: >-
    This task performs curl operation to transfer data from internet.

  params:
  - name: url
    description: URL to curl'ed
    type: string
  - name: options
    description: options of url
    type: array
    default: []
  - name: curl-image
    description: option of curl image
    type: string
    default: "curlimages/curl"
  steps:
  - name: curl
    image: "$(params.curl-image)"
    command: [curl]
    args: ["$(params.options[*])", "$(params.url)"]
...
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: docker-build
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: docker, build-image, push-image, dind
    tekton.dev/displayName: docker-build
spec:
  description: >-
    This task will build and push an image using docker.
    The task will build an out image out of a Dockerfile.
    This image will be pushed to an image registry.
    The image will be built and pushed using a dind sidecar over TCP+TLS.
  params:
  - name: image
    description: Reference of the image docker will produce.
  - name: builder_image
    description: The location of the docker builder image.
    default: docker
  - name: dockerfile
    description: Path to the Dockerfile to build.
    default: ./Dockerfile
  - name: context
    description: Path to the directory to use as context.
    default: .
  - name: build_extra_args
    description: Extra parameters passed for the build command when building images.
    default: ""
  - name: push_extra_args
    description: Extra parameters passed for the push command when pushing images.
    default: ""
  - name: insecure_registry
    description: Allows the user to push to an insecure registry that has been specified
    default: ""
  workspaces:
  - name: source
  results:
  - name: IMAGE_DIGEST
    description: Digest of the image just built.
  steps:
  - name: docker-build
    image: $(params.builder_image)
    env:
    # Connect to the sidecar over TCP, with TLS.
    - name: DOCKER_HOST
      value: tcp://localhost:2376
    # Verify TLS.
    - name: DOCKER_TLS_VERIFY
      value: '1'
    # Use the certs generated by the sidecar daemon.
    - name: DOCKER_CERT_PATH
      value: /certs/client
    workingDir: $(workspaces.source.path)
    script: |
      docker build \
        $(params.build_extra_args) \
        --no-cache \
        -f $(params.dockerfile) -t $(params.image) $(params.context)
    volumeMounts:
      - mountPath: /certs/client
        name: dind-certs
  - name: docker-push
    image: $(params.builder_image)
    env:
    # Connect to the sidecar over TCP, with TLS.
    - name: DOCKER_HOST
      value: tcp://localhost:2376
    # Verify TLS.
    - name: DOCKER_TLS_VERIFY
      value: '1'
    # Use the certs generated by the sidecar daemon.
    - name: DOCKER_CERT_PATH
      value: /certs/client
    - name: DOCKER_CA_PATH
      value: /certs/ca
    workingDir: $(workspaces.source.path)
    script: |
      docker push $(params.build_extra_args) $(params.image)
    volumeMounts:
      - mountPath: /certs/client
        name: dind-certs
      - mountPath: /tekton/home/.docker/config.json
        subPath: .dockerconfigjson
        name: image-push-creds
    # Wait for the dind
  sidecars:
  - image: docker:dind
    name: server
    args:
      - --storage-driver=vfs
      - --userland-proxy=false
      - --debug
      - --insecure-registry=$(params.insecure_registry)
    securityContext:
      privileged: true
    env:
    # Write generated certs to the path shared with the client.
    - name: DOCKER_TLS_CERTDIR
      value: /certs
    volumeMounts:
    - mountPath: /certs/client
      name: dind-certs
    # Wait for the dind daemon to generate the certs it will share with the
    # client.
    readinessProbe:
      periodSeconds: 1
      exec:
        command: ['ls', '/certs/client/ca.pem']
  volumes:
  - name: dind-certs
    emptyDir: {}
  - name: image-push-creds
    secret:
      secretName: image-push-creds
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: generate-build-id
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: build-tool
    tekton.dev/displayName: "buildid"
spec:
  description: >-
    Given a base version, this task generates a unique build id by appending
    the base-version to the current timestamp.

  params:
    - name: base-version
      description: Base product version
      type: string
      default: "1.0"
  results:
    - name: timestamp
      description: Current timestamp
    - name: build-id
      description: ID of the current build
  steps:
    - name: get-timestamp
      image: bash:latest
      script: |
        #!/usr/bin/env bash
        ts=`date "+%Y%m%d-%H%M%S"`
        echo "Current Timestamp: ${ts}"
        echo ${ts} | tr -d "\n" | tee $(results.timestamp.path)
    - name: get-buildid
      image: bash:latest
      script: |
        #!/usr/bin/env bash
        ts=`cat $(results.timestamp.path)`
        buildId=$(inputs.params.base-version)-${ts}
        echo ${buildId} | tr -d "\n" | tee $(results.build-id.path)
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: kubernetes-actions
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: CLI, kubectl, generic
    tekton.dev/displayName: "kubernetes actions"
spec:
  description: >-
    This task is the generic kubectl CLI task which can be used
    to run all kinds of k8s commands
  workspaces:
    - name: manifest-dir
    - name: kubeconfig-dir
  params:
    - name: script
      description: The Kubernetes CLI script to run
      type: string
      default: "kubectl $@"
    - name: args
      description: The Kubernetes CLI arguments to run
      type: array
      default:
        - "help"
    - name: image
      default: gcr.io/cloud-builders/kubectl #image is huge
      description: Kubectl wrapper image
  steps:
    - name: kubectl
      image: $(params.image)
      workingDir: $(workspaces.manifest-dir.path)
      script:
        $(params.script)
      args:
        - "$(params.args)"
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: git-cli
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: git
    tekton.dev/displayName: "git cli"
spec:
  description: >-
    This task can be used to perform git operations.

    Git command that needs to be run can be passed as a script to
    the task.This task needs authentication to git in order to push
    after the git operation.

  workspaces:
    - name: source
      description: A workspace that contains the fetched git repository.
    - name: input
      description: A workspace that contains file that needs to be added to git.
  params:
    - name: BASE_IMAGE
      description: |
        The base image for the task.
      type: string
      default: alpine/git:latest

    - name: GIT_USER_NAME
      type: string
      description: |
        Git user name for performing git operation.
      default: ""

    - name: GIT_USER_EMAIL
      type: string
      description: |
        Git user email for performing git operation.
      default: ""

    - name: GIT_SCRIPT
      description: The git script to run.
      type: string
      default: |
        git help

  results:
    - name: commit
      description: The precise commit SHA after the git operation.

  steps:
    - name: git
      image: $(params.BASE_IMAGE)
      workingDir: $(workspaces.source.path)
      script: |

        # Setting up the config for the git.
        git config --global user.email "$(params.GIT_USER_EMAIL)"
        git config --global user.name "$(params.GIT_USER_NAME)"

        $(params.GIT_SCRIPT)

        RESULT_SHA="$(git rev-parse HEAD | tr -d '\n')"
        EXIT_CODE="$?"
        if [ "$EXIT_CODE" != 0 ]
        then
          exit $EXIT_CODE
        fi
        # Make sure we don't add a trailing newline to the result!
        echo -n "$RESULT_SHA" > $(results.commit.path)
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: git-clone
  labels:
    app.kubernetes.io/version: "0.2"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: git
    tekton.dev/displayName: "git clone"
spec:
  description: >-
    These Tasks are Git tasks to work with repositories used by other tasks
    in your Pipeline.

    The git-clone Task will clone a repo from the provided url into the
    output Workspace. By default the repo will be cloned into the root of
    your Workspace. You can clone into a subdirectory by setting this Task's
    subdirectory param.

  workspaces:
    - name: output
      description: The git repo will be cloned onto the volume backing this workspace
  params:
    - name: url
      description: git url to clone
      type: string
    - name: revision
      description: git revision to checkout (branch, tag, sha, refâ€¦)
      type: string
      default: ""
    - name: refspec
      description: (optional) git refspec to fetch before checking out revision
      default: ""
    - name: submodules
      description: defines if the resource should initialize and fetch the submodules
      type: string
      default: "true"
    - name: depth
      description: performs a shallow clone where only the most recent commit(s) will be fetched
      type: string
      default: "1"
    - name: sslVerify
      description: defines if http.sslVerify should be set to true or false in the global git config
      type: string
      default: "true"
    - name: subdirectory
      description: subdirectory inside the "output" workspace to clone the git repo into
      type: string
      default: ""
    - name: deleteExisting
      description: clean out the contents of the repo's destination directory (if it already exists) before trying to clone the repo there
      type: string
      default: "true"
    - name: httpProxy
      description: git HTTP proxy server for non-SSL requests
      type: string
      default: ""
    - name: httpsProxy
      description: git HTTPS proxy server for SSL requests
      type: string
      default: ""
    - name: noProxy
      description: git no proxy - opt out of proxying HTTP/HTTPS requests
      type: string
      default: ""
    - name: verbose
      description: log the commands used during execution
      type: string
      default: "true"
  results:
    - name: commit
      description: The precise commit SHA that was fetched by this Task
    - name: url
      description: The precise URL that was fetched by this Task
  steps:
    - name: clone
      image: gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.16.2
      script: |
        #!/bin/sh
        set -eu -o pipefail

        if [[ "$(params.verbose)" == "true" ]] ; then
          set -x
        fi

        CHECKOUT_DIR="$(workspaces.output.path)/$(params.subdirectory)"

        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf $CHECKOUT_DIR" because $CHECKOUT_DIR might be "/"
          # or the root of a mounted volume.
          if [[ -d "$CHECKOUT_DIR" ]] ; then
            # Delete non-hidden files and directories
            rm -rf "$CHECKOUT_DIR"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "$CHECKOUT_DIR"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "$CHECKOUT_DIR"/..?*
          fi
        }

        if [[ "$(params.deleteExisting)" == "true" ]] ; then
          cleandir
        fi

        test -z "$(params.httpProxy)" || export HTTP_PROXY=$(params.httpProxy)
        test -z "$(params.httpsProxy)" || export HTTPS_PROXY=$(params.httpsProxy)
        test -z "$(params.noProxy)" || export NO_PROXY=$(params.noProxy)

        /ko-app/git-init \
          -url "$(params.url)" \
          -revision "$(params.revision)" \
          -refspec "$(params.refspec)" \
          -path "$CHECKOUT_DIR" \
          -sslVerify="$(params.sslVerify)" \
          -submodules="$(params.submodules)" \
          -depth "$(params.depth)"
        cd "$CHECKOUT_DIR"
        RESULT_SHA="$(git rev-parse HEAD)"
        EXIT_CODE="$?"
        if [ "$EXIT_CODE" != 0 ] ; then
          exit $EXIT_CODE
        fi
        # ensure we don't add a trailing newline to the result
        echo -n "$RESULT_SHA" > $(results.commit.path)
        echo -n "$(params.url)" > $(results.url.path)
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: git-rebase
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: git
    tekton.dev/displayName: "git rebase"
spec:
  description: >-
    These Tasks are Git tasks to work with repositories used by other tasks
    in your Pipeline.

    This task will rebase the branch based on the user input. Before rebase,
    if squashing of the commits is required, then it can be done by providing
    the squash count i.e number of commits to squash.

  workspaces:
    - name: source
      description: A workspace that contains the fetched git repository.
  params:
    - name: SQUASH_COUNT
      type: string
      description: |
        Number of commits to squash in the branch.
      default: "0"

    - name: COMMIT_MSG
      type: string
      description: |
        Commit message after the squash is done.
      default: ""

    - name: GIT_USER_NAME
      type: string
      description: |
        Git user name to use for rebase.

    - name: GIT_USER_EMAIL
      type: string
      description: |
        Git user email to use for rebase.

    - name: PULL_REMOTE_NAME
      type: string
      description: |
        Git remote name from which we have to pull and rebase.
      default: origin

    - name: PULL_REMOTE_URL
      type: string
      description: |
        Git remote URL from which we have to pull and rebase.

    - name: PULL_BRANCH_NAME
      type: string
      description: |
        Git branch name from which we have to pull and rebase.

    - name: PUSH_REMOTE_NAME
      type: string
      description: |
        Git remote name to push after rebase.
      default: origin

    - name: PUSH_REMOTE_URL
      type: string
      description: |
        Git remote URL to push after rebase.

    - name: PUSH_BRANCH_NAME
      type: string
      description: |
        Git branch to push after rebase.
  results:
    - name: commit
      description: The precise commit SHA after the rebase.
  steps:
    - name: rebase
      workingdir: $(workspaces.source.path)
      image: alpine/git:latest
      script: |

        # Setting up the config for the git.
        git config user.email "$(params.GIT_USER_EMAIL)"
        git config user.name "$(params.GIT_USER_NAME)"

        # Squashing the commits if required.
        if [ "$(params.SQUASH_COUNT)" != 0 ] ; then

          git reset --soft HEAD~$(params.SQUASH_COUNT)
          git add .
          git commit -m "$(params.COMMIT_MSG)"

        fi

        # Checking if remote is already set up or not.
        git ls-remote --exit-code $(params.PULL_REMOTE_NAME)

        # Setting up remote url for pull.
        if test $? != 0; then
          git remote add $(params.PULL_REMOTE_NAME) $(params.PULL_REMOTE_URL)
        fi

        # Pull and rebase
        git pull --rebase $(params.PULL_REMOTE_NAME) $(params.PULL_BRANCH_NAME)

        # Checking if remote is already set up or not.
        git ls-remote --exit-code $(params.PUSH_REMOTE_NAME)

        # Setting up remote url for push.
        if test $? != 0; then
          git remote add $(params.PUSH_REMOTE_NAME) $(params.PUSH_REMOTE_URL)
        fi

        # Force push after the rebase.
        git push $(params.PUSH_REMOTE_NAME) $(params.PUSH_BRANCH_NAME) -f

        RESULT_SHA="$(git rev-parse HEAD | tr -d '\n')"

        # Make sure we don't add a trailing newline to the result!
        echo -n "$RESULT_SHA" > $(results.commit.path)
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: helm-conftest
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: test
    tekton.dev/displayName: "helm conftest"
spec:
  description: >-
    These tasks make it possible to use Conftest within your Tekton pipelines

    Conftest is a tool for testing configuration files using Open Policy Agent.

  workspaces:
  - name: source
  params:
  - name: chart
    default: "."
  - name: policy
    default: "policy"
  - name: output
    default: "stdout"
  - name: args
    type: array
    default: []

  steps:
  - name: helm-conftest
    workingDir: $(workspaces.source.path)
    image: instrumenta/helm-conftest:latest
    command:
      - helm
      - conftest
      - $(params.chart)
      - -p
      - $(params.policy)
      - -o
      - $(params.output)
      - $(params.args)
...
# This Task will do a helm upgrade based on the given helm repo and chart
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: helm-upgrade-from-repo
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: helm
spec:
  description: >-
    These tasks will install / upgrade a helm chart into your Kubernetes /
    OpenShift Cluster using Helm

  params:
    - name: helm_repo
      description: "Specify a specific helm repo"
    - name: chart_name
      description: "Specify chart name that will be deployed"
    - name: release_version
      description: The helm release version in semantic versioning format
      default: "v1.0.0"
    - name: release_name
      description: The helm release name
      default: "helm-release"
    - name: release_namespace
      description: The helm release namespace
      default: ""
    - name: overwrite_values
      description: "Specify the values you want to overwrite, comma separated: autoscaling.enabled=true,replicas=1"
      default: ""
    - name: helm_version
      description: "Specify a specific helm version"
      default: "latest"
  steps:
    - name: upgrade-from-repo
      image: lachlanevenson/k8s-helm:$(inputs.params.helm_version)
      script: |
        echo current installed helm releases
        helm list --namespace "$(inputs.params.release_namespace)"
        echo parsing helms repo name...
        REPO=`echo "$(inputs.params.chart_name)" | cut -d "/" -f 1`
        echo adding helm repo...
        helm repo add $REPO "$(inputs.params.helm_repo)"
        echo adding updating repo...
        helm repo update
        echo installing helm chart...
        helm upgrade --wait --install --namespace "$(inputs.params.release_namespace)" $(inputs.params.release_name) $(inputs.params.chart_name) --debug --set "$(inputs.params.overwrite_values)"
  ...
  ---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: helm-upgrade-from-source
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: helm
spec:
  description: >-
    These tasks will install / upgrade a helm chart into your Kubernetes /
    OpenShift Cluster using Helm

  params:
    - name: charts_dir
      description: The directory in source that contains the helm chart
    - name: release_version
      description: The helm release version in semantic versioning format
      default: "v1.0.0"
    - name: release_name
      description: The helm release name
      default: "helm-release"
    - name: release_namespace
      description: The helm release namespace
      default: ""
    - name: overwrite_values
      description: "Specify the values you want to overwrite, comma separated: autoscaling.enabled=true,replicas=1"
      default: ""
    - name: helm_version
      description: "Specify a specific helm version"
      default: "latest"
  workspaces:
    - name: source
  steps:
    - name: upgrade
      image: lachlanevenson/k8s-helm:$(inputs.params.helm_version)
      workingDir: /workspace/source
      script: |
        echo current installed helm releases
        helm list --namespace "$(inputs.params.release_namespace)"

        echo installing helm chart...
        helm upgrade --install --wait --namespace "$(inputs.params.release_namespace)" --version $(inputs.params.release_version) $(inputs.params.release_name) $(inputs.params.charts_dir) --debug --set "$(inputs.params.overwrite_values)"
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: istio-canary-release
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: canary deployment, istio
    tekton.dev/displayName: "istio canary release"
spec:
  description: >-
    This task can be used to perform deployment of an application
    using canary release strategy.

    Using this task we can route the traffic to the deployments
    with the help of virtual service by specifying the weights to
    individual deployment.

  workspaces:
    - name: istio-manifest-dir
      description: >-
        The workspace consisting of Istio manifests such as Gateway,
        DestinationRule and VirtualService in case applying for the
        first time.
  params:
    - name: VS_NAME
      description: The virtual service name to be patched
      type: string
      default: ""
    - name: V1_WEIGHT
      description: The traffic percentage to be sent to version v1
      type: string
      default: ""
    - name: V2_WEIGHT
      description: The traffic percentage to be sent to version v2
      type: string
      default: ""
  steps:
    - name: canary-deploy
      image: quay.io/openshift/origin-cli:latest
      workingDir: $(workspaces.istio-manifest-dir.path)
      script: |
        #!/usr/bin/env bash

        cat <<EOF >/tmp/patch.yaml
        apiVersion: networking.istio.io/v1alpha3
        kind: VirtualService
        metadata:
          name: $(params.VS_NAME)
        spec:
          hosts:
            - "*"
          gateways:
            - app-gateway
          http:
            - route:
                - destination:
                    host: myapp
                    subset: v1
                  weight: $(params.V1_WEIGHT)
                - destination:
                    host: myapp
                    subset: v2
                  weight: $(params.V2_WEIGHT)
        EOF

        if [ -n "$(params.V1_WEIGHT)" -a -n "$(params.V2_WEIGHT)" ]; then
          kubectl replace -f /tmp/patch.yaml
        else
          kubectl apply -f ./
        fi
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: kaniko
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: image-build
spec:
  description: >-
    This Task builds source into a container image using Google's kaniko tool.

    Kaniko doesn't depend on a Docker daemon and executes each
    command within a Dockerfile completely in userspace. This enables
    building container images in environments that can't easily or
    securely run a Docker daemon, such as a standard Kubernetes cluster.

  params:
  - name: IMAGE
    description: Name (reference) of the image to build.
  - name: DOCKERFILE
    description: Path to the Dockerfile to build.
    default: ./Dockerfile
  - name: CONTEXT
    description: The build context used by Kaniko.
    default: ./
  - name: EXTRA_ARGS
    default: ""
  - name: BUILDER_IMAGE
    description: The image on which builds will run
    default: gcr.io/kaniko-project/executor:latest
  workspaces:
  - name: source
  results:
  - name: IMAGE-DIGEST
    description: Digest of the image just built.

  steps:
  - name: build-and-push
    workingDir: $(workspaces.source.path)
    image: $(params.BUILDER_IMAGE)
    # specifying DOCKER_CONFIG is required to allow kaniko to detect docker credential
    # https://github.com/tektoncd/pipeline/pull/706
    env:
    - name: DOCKER_CONFIG
      value: /tekton/home/.docker
    command:
    - /kaniko/executor
    - $(params.EXTRA_ARGS)
    - --dockerfile=$(params.DOCKERFILE)
    - --context=$(workspaces.source.path)/$(params.CONTEXT)  # The user does not need to care the workspace and the source.
    - --destination=$(params.IMAGE)
    - --oci-layout-path=$(workspaces.source.path)/$(params.CONTEXT)/image-digest
    # kaniko assumes it is running as root, which means this example fails on platforms
    # that default to run containers as random uid (like OpenShift). Adding this securityContext
    # makes it explicit that it needs to run as root.
    securityContext:
      runAsUser: 0
  - name: write-digest
    workingDir: $(workspaces.source.path)
    image: gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/imagedigestexporter:v0.16.2
    # output of imagedigestexport [{"key":"digest","value":"sha256:eed29..660","resourceRef":{"name":"myrepo/myimage"}}]
    command: ["/ko-app/imagedigestexporter"]
    args:
    - -images=[{"name":"$(params.IMAGE)","type":"image","url":"$(params.IMAGE)","digest":"","OutputImageDir":"$(workspaces.source.path)/$(params.CONTEXT)/image-digest"}]
    - -terminationMessagePath=$(params.CONTEXT)/image-digested
    securityContext:
      runAsUser: 0
  - name: digest-to-results
    workingDir: $(workspaces.source.path)
    image: stedolan/jq
    script: |
      cat $(params.CONTEXT)/image-digested | jq '.[0].value' -rj | tee /tekton/results/IMAGE-DIGEST
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: kubeconfig-creator
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: deploy
    tekton.dev/displayName: "kubeconfig creator"
spec:
  description: >-
    This Task do a similar job to the Cluster PipelineResource and
    are intended as its replacement.

    This task creates a kubeconfig file that can be used to configure access
    to the different clusters. A common use case for this task is to deploy your
    application/function on different clusters. The task will use the kubeconfigwriter
    image and the provided parameters to create a kubeconfig file that can be used by
    other tasks in the pipeline to access the target cluster.

  params:
    - name: name
      description: name of the cluster
      type: string
    - name: url
      description: address of the cluster
      type: string
    - name: username
      description: username for basic authentication to the cluster
      type: string
    - name: password
      description: password for basic authentication to the cluster
      type: string
      default: ""
    - name: cadata
      description: contains PEM-encoded certificate authority certificates
      type: string
      default: ""
    - name: clientKeyData
      description: contains PEM-encoded data from a client key file for TLS
      type: string
      default: ""
    - name: clientCertificateData
      description: contains PEM-encoded data from a client cert file for TLS
      type: string
      default: ""
    - name: namespace
      description: default namespace to use on unspecified requests
      type: string
      default: ""
    - name: token
      description: bearer token for authentication to the cluster
      type: string
      default: ""
    - name: insecure
      description: to indicate server should be accessed without verifying the TLS certificate
      type: string
      default: "false"
  workspaces:
    - name: output
  steps:
    - name: write
      image: gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/kubeconfigwriter:v0.16.2
      command: ["/ko-app/kubeconfigwriter"]
      args:
        # passing the required json in the form of string to generate the kubeconfig file.
        #
        - -clusterConfig
        - '{
              "name":"$(params.name)",
              "url":"$(params.url)",
              "username":"$(params.username)",
              "password":"$(params.password)",
              "cadata":"$(params.cadata)",
              "clientKeyData":"$(params.clientKeyData)",
              "clientCertificateData":"$(params.clientCertificateData)",
              "namespace":"$(params.namespace)",
              "token":"$(params.token)",
              "Insecure":$(params.insecure)
            }'
        # path to the destination directory, where kubeconfig file will be stored.
        - -destinationDir
        - '$(workspaces.output.path)'
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: kubernetes-actions
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: CLI, kubectl, generic
    tekton.dev/displayName: "kubernetes actions"
spec:
  description: >-
    This task is the generic kubectl CLI task which can be used
    to run all kinds of k8s commands
  workspaces:
    - name: manifest-dir
    - name: kubeconfig-dir
  params:
    - name: script
      description: The Kubernetes CLI script to run
      type: string
      default: "kubectl $@"
    - name: args
      description: The Kubernetes CLI arguments to run
      type: array
      default:
        - "help"
    - name: image
      default: gcr.io/cloud-builders/kubectl #image is huge
      description: Kubectl wrapper image
  steps:
    - name: kubectl
      image: $(params.image)
      workingDir: $(workspaces.manifest-dir.path)
      script:
        $(params.script)
      args:
        - "$(params.args)"
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: kubeval
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: test
spec:
  description: >-
    This task makes it possible to use Kubeval within your Tekton pipelines.

    Kubeval is a tool used for validating Kubernetes configuration files. By
    default the task will recursively scan the provided repository for YAML
    files and validate them against the Kubernetes schemas.

  workspaces:
  - name: source
  params:
  - name: files
    default: "."
  - name: output
    default: "stdout"
  - name: args
    type: array
    default: []

  steps:
  - name: kubeval
    workingDir: $(workspaces.source.path)
    image: garethr/kubeval:latest
    command:
      - kubeval
      - -d
      - $(params.files)
      - -o
      - $(params.output)
      - $(params.args)
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: s2i
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: image-build
spec:
  description: >-
    Source-to-Image (S2I) is a toolkit and workflow for building reproducible
    container images from source code

    S2I produces images by injecting source code into a base S2I container image
    and letting the container prepare that source code for execution. The base
    S2I container images contains the language runtime and build tools needed for
    building and running the source code.

  params:
  - name: BUILDER_IMAGE
    description: The location of the s2i builder image.
  - name: PATH_CONTEXT
    description: The location of the path to run s2i from.
    default: .
  - name: TLSVERIFY
    description: Verify the TLS on the registry endpoint (for push/pull to a non-TLS registry)
    default: 'true'
  - name: LOGLEVEL
    description: Log level when running the S2I binary
    default: '0'
  resources:
    outputs:
    - name: image
      type: image
  workspaces:
  - name: source
  steps:
  - name: generate
    command:
    - /usr/local/bin/s2i
    - --loglevel=$(params.LOGLEVEL)
    - build
    - $(params.PATH_CONTEXT)
    - $(params.BUILDER_IMAGE)
    - --as-dockerfile
    - /gen-source/Dockerfile.gen
    image: quay.io/openshift-pipeline/s2i:nightly
    volumeMounts:
    - mountPath: /gen-source
      name: gen-source
    workingDir: $(workspaces.source.path)
  - name: build
    command:
    - buildah
    - bud
    - --tls-verify=$(params.TLSVERIFY)
    - --layers
    - -f
    - /gen-source/Dockerfile.gen
    - -t
    - $(resources.outputs.image.url)
    - .
    image: quay.io/buildah/stable:v1.15.1
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
    - mountPath: /gen-source
      name: gen-source
    workingDir: /gen-source
  - name: push
    command:
    - buildah
    - push
    - --tls-verify=$(params.TLSVERIFY)
    - $(resources.outputs.image.url)
    - docker://$(resources.outputs.image.url)
    image: quay.io/buildah/stable:v1.15.1
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
  volumes:
  - emptyDir: {}
    name: varlibcontainers
  - emptyDir: {}
    name: gen-source
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: sendmail
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: mail
    tekton.dev/displayName: "send mail"
spec:
  description: >-
    This task sends a simple email to receivers via SMTP server

  params:
  - name: server
    type: string
    description: secret name for SMTP server information (url, port, password)
  - name: subject
    type: string
    description: plain text email subject
  - name: body
    type: string
    description: plain text email body
  - name: sender
    type: string
    description: sender email address
  - name: recipients
    type: string
    description: recipient email addresses (space delimited list)
  steps:
  - name: send
    image: python:3.8-alpine
    script: |
      #!/usr/bin/env python3
      import smtplib, ssl, os
      port = os.getenv('PORT')
      smtp_server = os.getenv('SERVER')
      sender_email = "$(params.sender)"
      receiver_emails = "$(params.recipients)"
      user = os.getenv('USER')
      password = os.getenv('PASSWORD')
      tls = os.getenv('TLS')
      message = f"""\
      Subject: $(params.subject)
      To: {receiver_emails}
      From: {sender_email}

      $(params.body)"""
      print(message)
      if tls == 'True':
          context = ssl.create_default_context()
          server = smtplib.SMTP_SSL(smtp_server, port, context=context)
      else:
          server = smtplib.SMTP(smtp_server, port)
      if password != '':
          server.login(user, password)
      for receiver in receiver_emails.split(' '):
          server.sendmail(sender_email, receiver, message)
      server.quit()
    env:
    - name: USER
      valueFrom:
        secretKeyRef:
          name: $(params.server)
          key: user
    - name: PASSWORD
      valueFrom:
        secretKeyRef:
          name: $(params.server)
          key: password
    - name: TLS
      valueFrom:
        secretKeyRef:
          name: $(params.server)
          key: tls
    - name: SERVER
      valueFrom:
        secretKeyRef:
          name: $(params.server)
          key: url
    - name: PORT
      valueFrom:
        secretKeyRef:
          name: $(params.server)
          key: port
...
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: shellcheck
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: linter
    tekton.dev/displayName: "Shellcheck"
spec:
  description: >-
    This task can be used to perform lint check on Shell Script files
  workspaces:
    - name: shared-workspace
      description: A workspace that contains the fetched git repository.
  params:
    - name: args
      type: array
      description: extra args needs to append
      default: ["--help"]
  steps:
    - name: lint-shell
      image: koalaman/shellcheck
      workingDir: $(workspaces.shared-workspace.path)
      command:
        - /bin/shellcheck
      args:
        - $(params.args)
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: tkn
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: cli
spec:
  description: >-
    This task performs operations on Tekton resources using tkn

  params:
  - name: tkn-image
    description: tkn CLI container image to run this task
    default: gcr.io/tekton-releases/dogfooding/tkn
  - name: ARGS
    type: array
    description: tkn CLI arguments to run
  steps:
    - name: tkn
      image: "$(params.tkn-image)"
      command: ["/usr/local/bin/tkn"]
      args: ["$(params.ARGS)"]
...
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: wget
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: download
spec:
  description: >-
    This task uses wget to download files from the internet to a workspace.

  params:
  - name: url
    description: The url we want to download file from
    type: string
    default: ""
  - name: diroptions
    description: The directory path we want to save file to
    type: array
    default: []
  - name: options
    description: The arguments to pass to wget
    type: array
    default: []
  - name: filename
    description: The filename we want to change our file to
    type: string
    default: ""
  - name: wget-option
    description: The wget docker image to be used
    type: string
    default: "buildpack-deps:stable-curl"
  workspaces:
  - name: wget-workspace
    description: The folder where we write the wget'ed file to
  steps:
  - name: wget
    image: "$(params.wget-option)"
    command: [wget]
    args: ["$(params.options[*])", "$(params.url)", "$(params.diroptions[*])", "$(workspaces.wget-workspace.path)/$(params.filename)"]
...
